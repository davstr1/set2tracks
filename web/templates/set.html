{% extends "base.html" %}

{% block content %}

<style>
  /* allows interaction on playlist when player is over. 
otherwise player playerMetaWrap takes all width 
even where the player is not behind*/
  #playerMetaWrap {
    pointer-events: none;
  }

  #playerWrap {
    pointer-events: auto;
  }
</style>



<div class="md:flex md:justify-between md:items-start p-4 pl-0 pr-0">
  <div class="pl-2">
    
    <h1 class="lg:text-2xl"><span class="discreet block">Tracklist from</span>
      <a target="_blank" href="https://youtu.be/{{set.video_id}}">{{set.title}}
        <svg class="w-6 h-6 fill-base-content hover:fill-primary inline ">
          <use xlink:href="#icon-link-external"></use>
        </svg>
      </a>
      {%if is_admin() %}
      <a href="{{url_for('admin.set_visibility_toggle',set_id=set.id)}}" class="text-gray-600">[{{ "Show" if set.hidden else "Hide" }}]
      </a>
      {%endif%}
    </h1>

    <p class="text-gray-600">
      <a href="{{url_for('set.sets',s='channelid:'+set.channel.id|string)}}">{{ set.channel.author }}</a> - {{ tpl_utils.km_number(set.channel.channel_follower_count) }} subs
      {%if is_admin() %}
      <a href="{{url_for('admin.channel_visibility_toggle',channel_id=set.channel.id)}}" class="text-gray-600">[{{ "Show" if set.channel.hidden else "Hide" }}
        ]</a> 
        <a href="{{url_for('admin.channel_followability_toggle',channel_id=set.channel.id)}}">[ Make {%if set.channel.followable %}un{% endif %}followable ]</a>
      {%endif%}

    <p class="text-gray-600">{{ tpl_utils.time_ago(set.publish_date,False) }} - {{ tpl_utils.km_number(set.view_count) }} views - {{ tpl_utils.km_number(set.like_count) }} likes</p>
  </div>
  <div class="mt-4 md:mt-0">
    {% if not set.playlist_id %}
    <a href="#" id="create-playlist-from-set-tracks" class="btn mb-4 btn-primary flex justify-center items-center">
      Create Playlist from set tracks
    </a>
    {% else %}
    <a href="{{url_for('playlist.show_playlist',playlist_id=set.playlist_id)}}" class="btn mb-4 flex justify-center items-center">
      View playlist created from set tracks
    </a>
    {% endif %}
    <a href="" id="add_all_tracks_to_playlist" class="btn  mb-4 flex justify-center items-center">
      Add all tracks to playlist
    </a>
  </div>
</div>


<div id="playerMetaWrap" class="flex flex-col items-center  p-4 sticky top-0 z-50 ">

  <div id="playerWrap" class=" w-3/6  z-50 relative">

    <div id="modifyLeftMargin" class=" relative ">
      <div class="absolute  flex items-center   -left-5 h-full">
        <div id="draggable" class="cursor-ew-resize opacity-30 hover:opacity-100 h-2/6 w-3 bg-gray-500 rounded-xl select-none">&nbsp;</div>
      </div>

      <div id="videoWrap" class="relative  overflow-auto  p-2">
        <div id="youtube-player" class="aspect-video"></div>
      </div>

    </div>


  </div>
</div>

<div id="containerUnderPlayer">
<h1  class="text-xl font-semibold mt-8 ">Tracks in Set</h1>
</div>
{% if not set.has_chapters %}
<p class="discreet text-xs italic">(No chapter markers found in this video. Track timestamps are approximate, based on auto detection.)</p>
{% endif %}
<p class="discreet text-xs italic">Accuracy may vary between genres. Please relax & enjoy (sometimes) unexpected discoveries. Can't blame the robot :)</p>



{% set tracks = set.tracks %}
{% include 'tracklist.html' %}

<script>
  document.querySelector('#add_all_tracks_to_playlist').addEventListener('click', function (event) {
    event.stopPropagation();
    event.preventDefault();
    showContextMenu(event, this);
  });


</script>

</div>


<div class="fixed bottom-0 w-full  text-center bg-primary-content z-50 border-t-2 p-2 text-xs lg:p-4 lg:text-xl">
  <a target="_blank" href="https://youtu.be/{{set.video_id}}" class="hover:text-primary">
    ‚ù§ Support your DJ! 
    <span class="inline-block lg:inline">Like, comment, and subscribe on YouTube</span>
    <svg class="w-6 h-6 fill-current inline hover:fill-primary">
      <use xlink:href="#icon-link-external"></use>
    </svg>
  </a>
</div>


<script>

  const setId = '{{set.id}}';

  audioPlayer = document.getElementById('audio-player');
  const draggable = document.getElementById('draggable');
  const modifyLeftMargin = document.getElementById('modifyLeftMargin');
  // @TODO : wrap classes are totally confusing
  const playerWrap = document.getElementById('playerWrap');
  const metaWrap = document.getElementById('playerMetaWrap');
  const playerTopWrap = playerWrap.parentElement;
  const videoWrap = document.getElementById('videoWrap');
  const containerUnderPlayer = document.getElementById('containerUnderPlayer');

  const h1 = document.querySelector('h1');
  let playerTopWrapHeight = playerTopWrap.offsetHeight;
  const playerVMargin = playerTopWrapHeight - playerWrap.offsetHeight;

  let VideoShrinkThresholdReached = false;
  const shrinkOnInitial = playerTopWrap.offsetTop;
  let shrinkOn = shrinkOnInitial;

  let isDragging = false;
  let startX;
  const playerFixedClasses = ['items-end', 'fixed', 'right-0'] // ,'animate-center-to-end'k'w-48', 'h-28', 'fixed', 'top-2', 'right-2'
  const playerScrolledClasses = ['items-center', 'sticky'] // ,'animate-end-to-center' ''right-2'','w-3/6', 'relative'


  var trackList = document.querySelectorAll('#tracklist .track');
  var activeTrack = null;




  function saveWrapWidth(width) {
    localStorage.setItem('wrapWidth', width);
    playerTopWrapHeight = modifyLeftMargin.offsetHeight + playerVMargin;


  }

  // Function to load the wrap width from localStorage
  function loadWrapWidth() {
    const wrapWidth = localStorage.getItem('wrapWidth');
    if (wrapWidth) {
      modifyLeftMargin.style.marginLeft = '0px';
      playerWrap.style.width = `${wrapWidth}px`;
    }
  }

  //

  window.addEventListener('load', function () {
    playerTopWrapHeight = playerTopWrap.offsetTop;
    shrinkOn = playerTopWrapHeight; // metaWrap.getBoundingClientRect().top +
    console.log('shrinkOn', shrinkOn)
    console.log('playerTopWrapHeight', playerTopWrapHeight)

  });

  window.addEventListener('DOMContentLoaded', loadWrapWidth);

  draggable.addEventListener('mousedown', (e) => {
    videoWrap.classList.add('pointer-events-none')
    isDragging = true;
    startX = e.clientX - modifyLeftMargin.offsetLeft;
  });

  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      let ml = e.clientX - startX;
      modifyLeftMargin.style.marginLeft = ml + 'px';
    }
  });

  document.addEventListener('mouseup', () => {
    isDragging = false;
    const wrapWidth = videoWrap.offsetWidth > 65 ? videoWrap.offsetWidth : 65;
    modifyLeftMargin.style.marginLeft = '0px';
    playerWrap.style.width = `${wrapWidth}px`;
    videoWrap.classList.remove('pointer-events-none')
    saveWrapWidth(wrapWidth);
  });




  window.addEventListener('scroll', function () {
    if (!VideoShrinkThresholdReached && window.scrollY > shrinkOn) {
      containerUnderPlayer.style.marginTop = `${metaWrap.offsetHeight}px`;
      metaWrap.classList.add(...playerFixedClasses);

      metaWrap.classList.remove(...playerScrolledClasses);
      
      //h1.style.marginTop = `${playerTopWrapHeight}px`;

      // setTimeout(() => {
      //   playerWrap.classList.remove('transition-all', 'duration-300');
      // }, 300);

      VideoShrinkThresholdReached = true;
    } else if (VideoShrinkThresholdReached && window.scrollY <= shrinkOn) {
      metaWrap.classList.add(...playerScrolledClasses);
      metaWrap.classList.remove(...playerFixedClasses);
      containerUnderPlayer.style.marginTop = '';
      //h1.style.marginTop = '';

      VideoShrinkThresholdReached = false;
    }
  });

  function onPlayerStateChange(event) {

    // If the player is not playing, stop the active track checking
    if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
      clearInterval(startActiveTrackChecking.intervalId);
      if (activeTrack) {
        activeTrack.classList.remove('playing');
      }

    } else if (event.data == YT.PlayerState.PLAYING) {
      // If playing, make sure the interval is running
      stopAndHideAudioPlayer()
      if (!startActiveTrackChecking.intervalId) {
        startActiveTrackChecking();
      }
      if (activeTrack) {
        activeTrack.classList.add('playing');
      }

    }

  }

  function startActiveTrackChecking() {
    setInterval(checkActiveTrack, 100); // Update every second
  }


  function getNewActiveTrack(currentTime) {

    for (let i = trackList.length - 1; i >= 0; i--) {
      let track = trackList[i];
      var startTime = parseInt(track.getAttribute('data-start_time'), 10);
      var endTime = parseInt(track.getAttribute('data-end_time'), 10);

      // var nextTrack = trackList[i + 1];

      // var nextStartTime = nextTrack ? parseInt(nextTrack.getAttribute('data-start_time'), 10) : Infinity; // Treat no next track as beyond any current time

      if (currentTime >= startTime && currentTime < endTime) {
        return track;
      }
    }

    return null;
  }




  function getStartTimeFromMousePosition(track, mouseX) {
    // Get the start time and end time from the track's data attributes
    const startTime = parseInt(track.getAttribute('data-start_time'));
    const endTime = parseInt(track.getAttribute('data-end_time'));
    const totalTime = endTime - startTime;

    // Get the bounding rectangle of the track element
    const trackRect = track.getBoundingClientRect();

    // Calculate the mouse position relative to the track element
    const relativeMouseX = mouseX - trackRect.left;

    // Calculate the percentage position of the mouse within the track element
    const percentagePosition = relativeMouseX / trackRect.width;

    // Calculate the corresponding time within the track's duration
    const correspondingTime = startTime + (percentagePosition * totalTime);

    return correspondingTime;
  }

  function checkActiveTrack() {
    if (!player) {
      return;
    }

    var currentTime = player.getCurrentTime();

    var currentTime = player.getCurrentTime();
    if (currentTime == lastCurrentTime) {
      return;
    }

    lastCurrentTime = currentTime;

    activeTrack = document.querySelector('#tracklist .track.active');
    var newActiveTrack = getNewActiveTrack(currentTime);



    if (activeTrack !== newActiveTrack) {

      console.log('newActiveTrack', newActiveTrack)
      console.log('currentTime', currentTime)
      if (activeTrack) {
        activeTrack.classList.remove('active', 'playing');
      }
      if (newActiveTrack) {
        console.log('adding active PLAYING')
        newActiveTrack.classList.add('active', 'playing');
      }
      activeTrack = newActiveTrack;

    }


    if (newActiveTrack) {
      // Get the start time and end time from the new active track's data attributes
      var startTime = parseInt(newActiveTrack.getAttribute('data-start_time'));
      var endTime = parseInt(newActiveTrack.getAttribute('data-end_time'));

      // Set the background width based on the current time
      setTrackBackgroundWidth(newActiveTrack, startTime, endTime, currentTime);
    }
  }


  function stopAndHideAudioPlayer() {
    var audioPlayer = document.getElementById('audio-player');
    if (audioPlayer.classList.contains('hidden')) {
      return;
    }
    audioPlayer.pause();
    audioPlayer.classList.add('hidden');
  }

  function onPlayerReady(e) {

    startActiveTrackChecking();
    var trackList = document.getElementById('tracklist');
    trackList.addEventListener('click', function (event) {



      stopAndHideAudioPlayer()
      var target = event.target.closest('div.track');

      if (target) {
        if (target.classList.contains('playing')) {
          const mouseX = event.clientX;
          var startTime = getStartTimeFromMousePosition(target, mouseX);
        } else if (target.classList.contains('active')) {
          var startTime = player.getCurrentTime();

        } else {
          var startTime = parseFloat(target.getAttribute('data-start_time'));
        }

        if (e.target && e.target.seekTo) {

          function checkAndSeek() {
            audioPlayer.pause();
            const playerState = e.target.getPlayerState();
            if (playerState === YT.PlayerState.PAUSED) {
              e.target.playVideo();
            } else if (playerState === YT.PlayerState.CUED) {
              // first time, a straight seekTo doesn't do it
              // video will start from a prev point if ever consulted
              // Api bug probably
              setTimeout(function () {
                player.seekTo(startTime, true);
              }, 300); //

            }

            player.seekTo(startTime, true);

          }

          // Start the check-and-seek process
          checkAndSeek();

        }
      } else {
        console.log('no target');
      }
    });
  }


  // This code loads the IFrame Player API code asynchronously.
  var tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  var lastCurrentTime = 0;
  var currentTime = 0;
  var player;
  function onYouTubeIframeAPIReady() {
    player = new YT.Player('youtube-player', {
      height: '100%',
      width: '100%',
      videoId: '{{set.video_id}}',

      playerVars: {
        start: 0,
        //'modestbranding':1 // not seeing any difference
      },
      // modestbranding: 1,
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
        //'onStateChange': onPlayerStateChange
      }
    });



  }

  function setTrackBackgroundWidth(track, startTime, endTime, position) {
    // Calculate the percentage width based on the position within the time range
    const totalTime = endTime - startTime;
    const percentageWidth = ((position - startTime) / totalTime) * 100;

    // Set the custom property for background width
    track.style.setProperty('--background-width', `${percentageWidth}%`);
  }

  // no youtube player, set the tracks to play preview on click
  if (typeof player !== 'undefined') {
    player.addEventListener('timeupdate', checkActiveTrack);
  }


  const createPlaylistButton = document.getElementById('create-playlist-from-set-tracks');

  if (createPlaylistButton) {
    createPlaylistButton.addEventListener('click', function (e) {
      e.preventDefault();
      const payload = {
        "set_id": setId
      }

      return processAjax('{{ url_for("playlist.jax_create_playlist_from_set_tracks") }}', 'POST', payload);
    });
  }

</script>


{% endblock %}