{% extends "base.html" %}

{% block content %}

<style>
  /* allows interaction on playlist when player is over. 
otherwise player playerMetaWrap takes all width 
even where the player is not behind*/
  #playerMetaWrap {
    pointer-events: none;
  }

  #playerWrap {
    pointer-events: auto;
  }
</style>



<div class="flex justify-end  items-start p-4">
  <a href="#"  id="create-playlist-from-set-tracks" class=" btn btn-primary flex justify-center items-center">

    Create Playlist from tracks
  </a>
</div>


<div id="playerMetaWrap" class="flex flex-col items-center  p-4 sticky top-0 z-50 ">
  <div id="playerWrap" class=" w-3/6  z-50 relative">

    <div id="modifyLeftMargin" class=" relative ">
      <div class="absolute  flex items-center   -left-5 h-full">
        <div id="draggable" class="cursor-ew-resize opacity-30 hover:opacity-100 h-2/6 w-3 bg-gray-500 rounded-xl select-none">&nbsp;</div>
      </div>

      <div id="videoWrap" class="relative  overflow-auto  p-2">
        <div id="youtube-player" class="aspect-video"></div>
      </div>

    </div>


  </div>
</div>
<h1 class="text-xl font-semibold mt-8 ">Tracks in Set</h1>

{% if not set.has_chapters %}
<p class="text-xs italic">(No chapter markers found in this video. Track timestamps are approximate, based on auto detection.)</p>
{% endif %}



{% set tracks = set.tracks %}
{% include 'tracklist.html' %}

</div>




<script>

  const setId = '{{set.id}}';

  audioPlayer = document.getElementById('audio-player');
  const draggable = document.getElementById('draggable');
  const modifyLeftMargin = document.getElementById('modifyLeftMargin');
  // @TODO : wrap classes are totally confusing
  const playerWrap = document.getElementById('playerWrap');
  const metaWrap = document.getElementById('playerMetaWrap');
  const playerTopWrap = playerWrap.parentElement;
  const videoWrap = document.getElementById('videoWrap');

  const h1 = document.querySelector('h1');
  let playerTopWrapHeight = playerTopWrap.offsetHeight;
  const playerVMargin = playerTopWrapHeight - playerWrap.offsetHeight;

  let VideoShrinkThresholdReached = false;
  const shrinkOnInitial = playerTopWrap.offsetTop;
  let shrinkOn = shrinkOnInitial;

  let isDragging = false;
  let startX;
  const playerFixedClasses = ['items-end'] // ,'animate-center-to-end'k'w-48', 'h-28', 'fixed', 'top-2', 'right-2'
  const playerScrolledClasses = ['items-center'] // ,'animate-end-to-center' ''right-2'','w-3/6', 'relative'


  var trackList = document.querySelectorAll('#tracklist .track');
  var activeTrack = null;




  function saveWrapWidth(width) {
    localStorage.setItem('wrapWidth', width);
    playerTopWrapHeight = modifyLeftMargin.offsetHeight + playerVMargin;


  }

  // Function to load the wrap width from localStorage
  function loadWrapWidth() {
    const wrapWidth = localStorage.getItem('wrapWidth');
    if (wrapWidth) {
      modifyLeftMargin.style.marginLeft = '0px';
      playerWrap.style.width = `${wrapWidth}px`;
    }
  }

  //

  window.addEventListener('load', function () {
    playerTopWrapHeight = playerTopWrap.offsetHeight;
    shrinkOn = metaWrap.getBoundingClientRect().top;;

  });

  window.addEventListener('DOMContentLoaded', loadWrapWidth);

  draggable.addEventListener('mousedown', (e) => {
    videoWrap.classList.add('pointer-events-none')
    isDragging = true;
    startX = e.clientX - modifyLeftMargin.offsetLeft;
  });

  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      let ml = e.clientX - startX;
      modifyLeftMargin.style.marginLeft = ml + 'px';
    }
  });

  document.addEventListener('mouseup', () => {
    isDragging = false;
    const wrapWidth = videoWrap.offsetWidth > 65 ? videoWrap.offsetWidth : 65;
    modifyLeftMargin.style.marginLeft = '0px';
    playerWrap.style.width = `${wrapWidth}px`;
    videoWrap.classList.remove('pointer-events-none')
    saveWrapWidth(wrapWidth);
  });




  window.addEventListener('scroll', function () {
    if (!VideoShrinkThresholdReached && window.scrollY > shrinkOn) {
      metaWrap.classList.add(...playerFixedClasses);

      metaWrap.classList.remove(...playerScrolledClasses);
      //h1.style.marginTop = `${playerTopWrapHeight}px`;

      // setTimeout(() => {
      //   playerWrap.classList.remove('transition-all', 'duration-300');
      // }, 300);

      VideoShrinkThresholdReached = true;
    } else if (VideoShrinkThresholdReached && window.scrollY <= shrinkOn) {
      metaWrap.classList.add(...playerScrolledClasses);
      metaWrap.classList.remove(...playerFixedClasses);
      //h1.style.marginTop = '';

      VideoShrinkThresholdReached = false;
    }
  });

  function onPlayerStateChange(event) {

    // If the player is not playing, stop the active track checking
    if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
      clearInterval(startActiveTrackChecking.intervalId);
      if (activeTrack) {
        activeTrack.classList.remove('playing');
      }

    } else if (event.data == YT.PlayerState.PLAYING) {
      // If playing, make sure the interval is running
      stopAndHideAudioPlayer()
      if (!startActiveTrackChecking.intervalId) {
        startActiveTrackChecking();
      }
      if (activeTrack) {
        activeTrack.classList.add('playing');
      }

    }

  }

  function startActiveTrackChecking() {
    setInterval(checkActiveTrack, 100); // Update every second
  }


  function getNewActiveTrack(currentTime) {

    for (let i = trackList.length - 1; i >= 0; i--) {
      let track = trackList[i];
      var startTime = parseInt(track.getAttribute('data-start_time'), 10);
      var endTime = parseInt(track.getAttribute('data-end_time'), 10);

      // var nextTrack = trackList[i + 1];

      // var nextStartTime = nextTrack ? parseInt(nextTrack.getAttribute('data-start_time'), 10) : Infinity; // Treat no next track as beyond any current time

      if (currentTime >= startTime && currentTime < endTime) {
        return track;
      }
    }

    return null;
  }




  function getStartTimeFromMousePosition(track, mouseX) {
    // Get the start time and end time from the track's data attributes
    const startTime = parseInt(track.getAttribute('data-start_time'));
    const endTime = parseInt(track.getAttribute('data-end_time'));
    const totalTime = endTime - startTime;

    // Get the bounding rectangle of the track element
    const trackRect = track.getBoundingClientRect();

    // Calculate the mouse position relative to the track element
    const relativeMouseX = mouseX - trackRect.left;

    // Calculate the percentage position of the mouse within the track element
    const percentagePosition = relativeMouseX / trackRect.width;

    // Calculate the corresponding time within the track's duration
    const correspondingTime = startTime + (percentagePosition * totalTime);

    return correspondingTime;
  }

  function checkActiveTrack() {
    if (!player) {
      return;
    }

    var currentTime = player.getCurrentTime();

    var currentTime = player.getCurrentTime();
    if (currentTime == lastCurrentTime) {
      return;
    }

    lastCurrentTime = currentTime;

    activeTrack = document.querySelector('#tracklist .track.active');
    var newActiveTrack = getNewActiveTrack(currentTime);



    if (activeTrack !== newActiveTrack) {

      console.log('newActiveTrack', newActiveTrack)
      console.log('currentTime', currentTime)
      if (activeTrack) {
        activeTrack.classList.remove('active', 'playing');
      }
      if (newActiveTrack) {
        console.log('adding active PLAYING')
        newActiveTrack.classList.add('active', 'playing');
      }
      activeTrack = newActiveTrack;

    }


    if (newActiveTrack) {
      // Get the start time and end time from the new active track's data attributes
      var startTime = parseInt(newActiveTrack.getAttribute('data-start_time'));
      var endTime = parseInt(newActiveTrack.getAttribute('data-end_time'));

      // Set the background width based on the current time
      setTrackBackgroundWidth(newActiveTrack, startTime, endTime, currentTime);
    }
  }


  function stopAndHideAudioPlayer() {
    var audioPlayer = document.getElementById('audio-player');
    if (audioPlayer.classList.contains('hidden')) {
      return;
    }
    audioPlayer.pause();
    audioPlayer.classList.add('hidden');
  }

  function onPlayerReady(e) {

    startActiveTrackChecking();
    var trackList = document.getElementById('tracklist');
    trackList.addEventListener('click', function (event) {



      stopAndHideAudioPlayer()
      var target = event.target.closest('div.track');

      if (target) {
        if (target.classList.contains('playing')) {
          const mouseX = event.clientX;
          var startTime = getStartTimeFromMousePosition(target, mouseX);
        } else if (target.classList.contains('active')) {
          var startTime = player.getCurrentTime();

        } else {
          var startTime = parseFloat(target.getAttribute('data-start_time'));
        }

        if (e.target && e.target.seekTo) {

          function checkAndSeek() {
            audioPlayer.pause();
            const playerState = e.target.getPlayerState();
            if (playerState === YT.PlayerState.PAUSED) {
              e.target.playVideo();
            } else if (playerState === YT.PlayerState.CUED) {
              // first time, a straight seekTo doesn't do it
              // video will start from a prev point if ever consulted
              // Api bug probably
              setTimeout(function () {
                player.seekTo(startTime, true);
              }, 300); //

            }

            player.seekTo(startTime, true);

          }

          // Start the check-and-seek process
          checkAndSeek();

        }
      } else {
        console.log('no target');
      }
    });
  }


  // This code loads the IFrame Player API code asynchronously.
  var tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  var lastCurrentTime = 0;
  var currentTime = 0;
  var player;
  function onYouTubeIframeAPIReady() {
    player = new YT.Player('youtube-player', {
      height: '100%',
      width: '100%',
      videoId: '{{set.video_id}}',

      playerVars: {
        start: 0,
        //'modestbranding':1 // not seeing any difference
      },
      // modestbranding: 1,
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
        //'onStateChange': onPlayerStateChange
      }
    });



  }

  function setTrackBackgroundWidth(track, startTime, endTime, position) {
    // Calculate the percentage width based on the position within the time range
    const totalTime = endTime - startTime;
    const percentageWidth = ((position - startTime) / totalTime) * 100;

    // Set the custom property for background width
    track.style.setProperty('--background-width', `${percentageWidth}%`);
  }

  // no youtube player, set the tracks to play preview on click
  if (typeof player !== 'undefined') {
    player.addEventListener('timeupdate', checkActiveTrack);
  }


  document.getElementById('create-playlist-from-set-tracks').addEventListener('click', function (e) {
    e.preventDefault();
    const payload = {
      "set_id": setId
    }

    return processAjax('{{ url_for("main.jax_create_playlist_from_set_tracks") }}','POST',payload)

  });

</script>


{% endblock %}